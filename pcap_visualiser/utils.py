from scapy.utils import rdpcap
from itertools import chain
import logging
import os
from collections import OrderedDict
import networkx
import itertools
from networkx import DiGraph



def load_file(pcap_file_paths=[]):
    return list(chain(*[rdpcap(_file) for _file in pcap_file_paths]))

def get_node_info(node, data, layer, geo_ip):
    """get the geo information for each node

    Args:
        node (Graph): graph object for a packet address
    """
    data[node] = {}
    city = None
    country = None
    if layer >= 3 and geo_ip:
        if layer == 3:
            data[node]['ip'] = node
        elif layer == 4:
            data[node]['ip'] = node.split(':')[0]
        node_ip = data[node]['ip']
        try:
            mmdbrec = geo_ip.get(node_ip)
            if mmdbrec != None:
                countryrec = mmdbrec.get('city',None)
                cityrec = mmdbrec.get('country',None)
                if countryrec: # some records have one but not the other....
                    country = countryrec['names'].get(args.geolang, None)
                if cityrec:
                    city =  cityrec['names'].get(args.geolang,None)
            data[node]['country'] = country if country else 'private'
            data[node]['city'] = city if city else 'private'
        except:
            logging.debug("could not load GeoIP data for node %s" % node_ip)
            
    elif layer == 2:
        data[node]['mac'] = node

def get_edge_info(graph, src, dst):
    edge = graph[src][dst]
    if edge:
        packets = edge['packets']
        edge['layers'] = set(list(itertools.chain(*[set(list(PcapGraph.expand(p))) for p in packets])))
        edge['transmitted'] = sum(len(p) for p in packets)
        edge['connections'] = len(packets)


def draw(data, graph, layer, args, filename=None):
    graph.label ="Layer %d traffic graph for packets from %s" % (layer,str(args.pcaps))
    
    # get graphviz format
    agraph = networkx.drawing.nx_agraph.to_agraph(self.graph)
    # remove packet information (blows up file size)
    for edge in agraph.edges():
        del edge.attr['packets']
    if filename:
        agraph.write(filename)
    return agraph
    
    for node in graph.nodes():
        if node not in data:
            # node might be deleted, because it's not legit etc.
            continue
        snode = str(node)
        nnode = self.lookup(snode)
        node.attr['shape'] = args.shape
        node.attr['fontsize'] = '10'
        node.attr['width'] = '0.5'
        node.attr['color'] = 'linen'
        node.attr['style'] = 'filled,rounded'
        if 'country' in data[snode]:
            country_label = data[snode]['country']
            city_label = data[snode]['city']
            if nnode != snode:
                nodelab = '%s\n%s' % (nnode,snode)
            else:
                nodelab = snode
            if country_label != 'private':
                if city_label == 'private':
                    nodelab += "\n(%s)" % (country_label)
                else:
                    nodelab += "\n(%s, %s)" % (city_label, country_label)
            node.attr['label'] = nodelab
            if not (country_label == 'private'):
                node.attr['color'] = 'lightyellow'
                #TODO add color based on country or scan?
    for edge in graph.edges():
        connection = graph[edge[0]][edge[1]]
        edge.attr['label'] = 'transmitted: %i bytes\n%s ' % (connection['transmitted'], ' | '.join(connection['layers']))
        edge.attr['fontsize'] = '8'
        edge.attr['minlen'] = '2'
        edge.attr['penwidth'] = min(max(0.05,connection['connections'] * 1.0 / len(graph.nodes())), 2.0)
    graph.layout(prog=args.layoutengine)
    graph.draw(filename)